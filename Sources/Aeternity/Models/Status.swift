//
// Status.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct Status: Codable, Hashable {

    /** Base58Check encoded tagged hash */
    public var genesisKeyBlockHash: String
    public var solutions: ModelUInt64
    public var difficulty: ModelUInt64
    public var syncing: Bool
    public var syncProgress: Float?
    public var listening: Bool
    public var protocols: [ModelProtocol]
    public var nodeVersion: String
    public var nodeRevision: String
    public var peerCount: ModelUInt32
    public var peerConnections: PeerConnections
    public var pendingTransactionsCount: ModelUInt32
    public var networkId: String
    /** Base58Check encoded tagged pubkey */
    public var peerPubkey: String
    /** Base58Check encoded tagged hash */
    public var topKeyBlockHash: String
    public var topBlockHeight: ModelUInt64

    public init(genesisKeyBlockHash: String, solutions: ModelUInt64, difficulty: ModelUInt64, syncing: Bool, syncProgress: Float? = nil, listening: Bool, protocols: [ModelProtocol], nodeVersion: String, nodeRevision: String, peerCount: ModelUInt32, peerConnections: PeerConnections, pendingTransactionsCount: ModelUInt32, networkId: String, peerPubkey: String, topKeyBlockHash: String, topBlockHeight: ModelUInt64) {
        self.genesisKeyBlockHash = genesisKeyBlockHash
        self.solutions = solutions
        self.difficulty = difficulty
        self.syncing = syncing
        self.syncProgress = syncProgress
        self.listening = listening
        self.protocols = protocols
        self.nodeVersion = nodeVersion
        self.nodeRevision = nodeRevision
        self.peerCount = peerCount
        self.peerConnections = peerConnections
        self.pendingTransactionsCount = pendingTransactionsCount
        self.networkId = networkId
        self.peerPubkey = peerPubkey
        self.topKeyBlockHash = topKeyBlockHash
        self.topBlockHeight = topBlockHeight
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case genesisKeyBlockHash = "genesis_key_block_hash"
        case solutions
        case difficulty
        case syncing
        case syncProgress = "sync_progress"
        case listening
        case protocols
        case nodeVersion = "node_version"
        case nodeRevision = "node_revision"
        case peerCount = "peer_count"
        case peerConnections = "peer_connections"
        case pendingTransactionsCount = "pending_transactions_count"
        case networkId = "network_id"
        case peerPubkey = "peer_pubkey"
        case topKeyBlockHash = "top_key_block_hash"
        case topBlockHeight = "top_block_height"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(genesisKeyBlockHash, forKey: .genesisKeyBlockHash)
        try container.encode(solutions, forKey: .solutions)
        try container.encode(difficulty, forKey: .difficulty)
        try container.encode(syncing, forKey: .syncing)
        try container.encodeIfPresent(syncProgress, forKey: .syncProgress)
        try container.encode(listening, forKey: .listening)
        try container.encode(protocols, forKey: .protocols)
        try container.encode(nodeVersion, forKey: .nodeVersion)
        try container.encode(nodeRevision, forKey: .nodeRevision)
        try container.encode(peerCount, forKey: .peerCount)
        try container.encode(peerConnections, forKey: .peerConnections)
        try container.encode(pendingTransactionsCount, forKey: .pendingTransactionsCount)
        try container.encode(networkId, forKey: .networkId)
        try container.encode(peerPubkey, forKey: .peerPubkey)
        try container.encode(topKeyBlockHash, forKey: .topKeyBlockHash)
        try container.encode(topBlockHeight, forKey: .topBlockHeight)
    }
}

